---
title: "실행 컨텍스트(Execution Context)(작성중)"
excerpt: " :computer: 프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다."

categories:
  - executionContext
tags:
  - F/E
  - 실행컨텍스트
  - Execution Context
toc: true
toc_sticky: true
toc_label: "POST LIST"
---

<hr>
:raising_hand:  ```프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다.```
<hr>

#### 1. 개요

---

좋은 기회로 `실행컨텍스트(Execution Context)` 에 대한 궁금증을 갖게 되었다.

중요한 부분은 이 `실행 컨텍스트`가 `Javascript` 에서 굉장히 중요한 역할을 하고 있다는 것이고 아직까지 깊게 공부를 해본적이 없어 이번 기회에 정확히 짚어가고 싶어서 기록을 시작해본다.

여러 기술블로그들을 보며 나름대로 정리해 보았다.

이번 포스팅에서는 어떻게 `실행 컨텍스트`가 실행되고 `Call Stack`에 쌓이고 `전역, 함수 컨텍스트`는 무엇인지 알아봐야겠다.

#### 2. 실행 컨텍스트란 무엇일까?

---

실행 컨텍스트는 아래와 같은 개념을 가지고 있다.

```
실행 컨텍스트의 정의

- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체
- 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념
```

즉, `실행 컨텍스트`란 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로서, 동일한 스코프에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 컨텍스트를 구성하고, 이를 `Call Stack`에 쌓아서 실행 순서를 보장한다로 `코어 자바스크립트`책에서는 정의하고 있다.

우리가 이러한 `실행 컨텍스트`를 알아야 하는 이유는 `실행 컨텍스트`가 활성화 될때 발생하는 현상들을 잘 파악하여 개발해야 되기 때문이다.

먼저 `Javascript`는 `실행 컨텍스트`가 활성화 되는 시점에 아래와 같은 현상들이 발생한다.

- `호이스팅`이 발생한다([다른 포스팅에서 다루고 있음](https://jjou33.github.io/javascript/Hoisting/))
- `외부 환경 정보`를 `구성`한다.
- `this` 값을 설정한다.

#### 3. 실행 컨텍스트 구성

---

여러가지 `Javascript`에서 발생하는 현상들과 `실행 컨텍스트`는 많은 관련이 있기 때문에 관련되서도 조금 더 공부가 필요할 것 같다.

`실행 컨텍스트`는 아래와 같은 경우에 `Call Stack`에 쌓이고 실행되게 된다.

- 전역 컨텍스트
  - `전역공간`은 자동으로 컨텍스트로 구성된다. 여기서 변수 객체를 생성하는 대신 `this`를 `전역 객체(Global Object)로 활용한다.
- 함수 컨텍스트
  - `함수`를 실행할 경우 `실행 컨텍스트`가 생성되고, 함수가 동작을 다하면 `Call Stack`에서 삭제된다.
- `eval()`함수를 실행할 경우
- `block`을 만들 경우

실행컨텍스트 요소는 다음과 같이 구성된다.

- 변수 객체(arguments, variable)
- scope chain
- this

일반적으로 함수를 이용한 `실행 컨텍스트`를 많이 사용한다.

실제 예시를 통해 어떻게 해당 값들이 구분되는지 확인해 보자.

```js
var name = "hyunwoo";
function writeName(text) {
  console.log(text + name);
}

function execute() {
  var name = "Super Hyunwoo";
  writeName("HI ");
}
execute();
```

위 실행결과에 따른 컨텍스트 생성은 아래와 같이 될 수 있습니다.

```js
- 전역 컨텍스트
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name', 'writeName', 'execute']
  }
  scopeChain: ['전역 변수 객체']
  this: window
}

- execute 함수 컨텍스트
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name' ]
  },
  scopeChain: [ 'execute 변수 객체', '전역 변수 객체'],
  this: window
}

- writeName 함수 컨텍스트
{
  '변수 객체': {
    arguments: [{ text: 'HI ' }],
    variable: null
  },
  scopeChain: [ 'writeName 변수 객체', '전역 변수 객체'],
  this: window
}
```

여기서 결과적으로 찍히는 로그는 아래와 같이 `HI hyunwoo` 가 된다.

이유는 `writeName` 함수 컨텍스트 `ScopeChain`에서 `name`을 찾을 수 없기 때문에 `HI Super Hyunwoo` 가 아닌 전역으로 설정된 `HI hyunwoo`가 나오게 된다.

![image](https://user-images.githubusercontent.com/56063287/157463930-bbac5406-8e2d-46f0-b55d-988e491948e3.png)

#### 실행 컨텍스트의 Call Stack 순서와 기능

---

```js
var a = 1; // 전역 컨텍스트
function outer() {
  // outer 컨텍스트
  function inner() {
    // inner 컨텍스트
    console.log(a); // undefined
    var a = 3;
    console.log(a); // 3
  }
  inner();
  console.log(a); // 1
}
outer();
console.log(a); // 1
```

위와 같은 소스가 실행되게 되면 어떤 순서로 `Call Stack`이 쌓이는지 알아본다.

- Javascript 실행: `[전역컨텍스트]`
- outer 실행: [전역컨텍스트, outer]
- inner 실행: [전역컨텍스트, outer, inner]
- inner 종료: [전역컨텍스트, outer]
- outer 종료: [전역컨텍스트]

![image](https://user-images.githubusercontent.com/56063287/157466130-18ea5664-1c0d-40e4-a86d-950dea34f04a.png)

- 이미지 참조 : [https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context](https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context)

`javascript`파일이 최초 실행 시점에 `전역 컨텍스트`가 활성화되고 `Call Stack`에

#### 참고 사이트

---

[https://kr.vuejs.org/v2/guide/instance.html#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9B%85](https://kr.vuejs.org/v2/guide/instance.html#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9B%85)

[https://wormwlrm.github.io/2018/12/29/Understanding-Vue-Lifecycle-hooks.html](https://wormwlrm.github.io/2018/12/29/Understanding-Vue-Lifecycle-hooks.html)

[https://cornswrold.tistory.com/342](https://cornswrold.tistory.com/342)
