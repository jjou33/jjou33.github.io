---
title: "실행 컨텍스트(Execution Context)(작성중)"
excerpt: " :computer: 프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다."

categories:
  - sdfg
tags:
  - F/E
  - 실행컨텍스트
  - Execution Context
toc: true
toc_sticky: true
toc_label: "POST LIST"
---

<hr>
:raising_hand:  ```프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다.```
<hr>

#### 1. 개요

---

좋은 기회로 `실행컨텍스트(Execution Context)` 에 대한 궁금증을 갖게 되었다.

중요한 부분은 이 `실행 컨텍스트`가 `Javascript` 에서 굉장히 중요한 역할을 하고 있다는 것이고 아직까지 깊게 공부를 해본적이 없어 이번 기회에 정확히 짚어가고 싶어서 기록을 시작해본다.

여러 기술블로그들을 보며 나름대로 정리해 보았다.

#### 2. 실행 컨텍스트란 무엇일까?

---

실행 컨텍스트는 아래와 같은 개념을 가지고 있다.

```
실행 컨텍스트의 정의

- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체
- 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념
```

즉, `실행 컨텍스트`란 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로서, 동일한 스코프에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 컨텍스트를 구성하고, 이를 `Call Stack`에 쌓아서 실행 순서를 보장한다로 `코어 자바스크립트`책에서는 정의하고 있다.

우리가 이러한 `실행 컨텍스트`를 알아야 하는 이유는 `실행 컨텍스트`가 활성화 될때 발생하는 현상들을 잘 파악하여 개발해야 되기 때문이다.

먼저 `Javascript`는 `실행 컨텍스트`가 활성화 되는 시점에 아래와 같은 현상들이 발생한다.

- `호이스팅`이 발생한다([다른 포스팅에서 다루고 있음](https://jjou33.github.io/javascript/Hoisting/))
- `외부 환경 정보`를 `구성`한다.
- `this` 값을 설정한다.

#### 3. 실행 컨텍스트(Execution Context) 구성

---

여러가지 `Javascript`에서 발생하는 현상들과 `실행 컨텍스트`는 많은 관련이 있기 때문에 관련되서도 조금 더 공부가 필요할 것 같다.

`실행 컨텍스트`는 아래와 같은 경우에 `Call Stack`에 쌓이고 실행되게 된다.

- 전역 컨텍스트
  - `전역공간`은 자동으로 컨텍스트로 구성된다. 여기서 변수 객체를 생성하는 대신 `this`를 `전역 객체(Global Object)로 활용한다.
- 함수 컨텍스트
  - `함수`를 실행할 경우 `실행 컨텍스트`가 생성되고, 함수가 동작을 다하면 `Call Stack`에서 삭제된다.
- `eval()`함수를 실행할 경우
- `block`을 만들 경우

실행컨텍스트 요소는 다음과 같이 구성된다.

- 변수 객체(arguments, variable)
- scope chain
- this

일반적으로 함수를 이용한 `실행 컨텍스트`를 많이 사용한다.

실제 예시를 통해 어떻게 해당 값들이 구분되는지 확인해 보자.

```js
var name = "hyunwoo";
function writeName(text) {
  console.log(text + name);
}

function execute() {
  var name = "Super Hyunwoo";
  writeName("HI ");
}
execute();
```

위 실행결과에 따른 컨텍스트 생성은 아래와 같이 될 수 있습니다.

```js
- 전역 컨텍스트
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name', 'writeName', 'execute']
  }
  scopeChain: ['전역 변수 객체']
  this: window
}

- execute 함수 컨텍스트
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name' ]
  },
  scopeChain: [ 'execute 변수 객체', '전역 변수 객체'],
  this: window
}

- writeName 함수 컨텍스트
{
  '변수 객체': {
    arguments: [{ text: 'HI ' }],
    variable: null
  },
  scopeChain: [ 'writeName 변수 객체', '전역 변수 객체'],
  this: window
}
```

여기서 결과적으로 찍히는 로그는 아래와 같이 `HI hyunwoo` 가 된다.

이유는 `writeName` 함수 컨텍스트 `ScopeChain`에서 `name`을 찾을 수 없기 때문에 `HI Super Hyunwoo` 가 아닌 전역으로 설정된 `HI hyunwoo`가 나오게 된다.

![image](https://user-images.githubusercontent.com/56063287/157463930-bbac5406-8e2d-46f0-b55d-988e491948e3.png)

#### 실행 컨텍스트의 Call Stack 순서와 기능

---

```js
var a = 1; // 전역 컨텍스트
function outer() {
  // outer 컨텍스트
  function inner() {
    // inner 컨텍스트
    console.log(a); // undefined
    var a = 3;
    console.log(a); // 3
  }
  inner();
  console.log(a); // 1
}
outer();
console.log(a); // 1
```

위와 같은 소스가 실행되게 되면 어떤 순서로 `Call Stack`이 쌓이는지 알아본다.

- Javascript 실행: **[전역컨텍스트]**
- outer 실행 : **[전역컨텍스트, outer]**
- inner 실행 : **[전역컨텍스트, outer, inner]**
- inner 종료 : **[전역컨텍스트, outer]**
- outer 종료 : **[전역컨텍스트]**

![image](https://user-images.githubusercontent.com/56063287/157466130-18ea5664-1c0d-40e4-a86d-950dea34f04a.png)

- 이미지 참조 : [https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context](https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context)

`javascript`파일이 최초 실행 시점에 `전역 컨텍스트`가 활성화되고 `Call Stack`에 쌓이게 된다.

이후 `outer` 함수가 실행되면 `자바스크립트 엔진`은 `outer`에 대한 `환경 정보`를 수집해서 `outer` 실행 컨텍스트를 생성 후 `Call Stack`에 쌓는다.

이후 `outer` 함수 내부의 `inner` 함수의 실행과 동시에 `inner`실행 컨텍스트가 생성되어 스택에 쌓이게 되면 `outer` 컨텍스트는 중단하고 `inner` 함수 내부 코드를 실행한다.

`inner` 함수의 실행이 종료되면 `Call Stack`에서 해당 컨텍스트가 제거되고 `outer` 함수가 이어서 진행된다.

이와 같은 방식을 알기위해 `실행 컨텍스트`를 구성할때 우리가 알아야 되는 부분들이 있다.

1. `VariableEnvironment`
2. `Lexical Environment`

##### 1. Lexical Environment

---

`Lexical Environment`는 `Javascript Engine`이 현재 읽고 있는 코드의 `Scope` 혹은 `Environment`를 말한다.

새로운 `Lexical Environment`는 괄로({})가 있을때마다 생성된다.

또한 `실행 컨텍스트`가 `JavaScript Engine`에게 현재의 `Lexical Environment`를 알려주는 역할을 하고 이에 맞게 사용할 수 있는 변수를 설정한다.

##### 2. Variable Environment

---

`Variable Environment`의 구성요소 및 `Variable Environment`와 `Lexical Environment`의 차이를 알아본다.

먼저 `Variable Environment`는 `environment record`, `outer environment reference`, `ThisBinding`으로 구성된다.

##### 2-1. Environment Record

---

- 현재 문맥의 식별자 정보(변수나 함수)
  - `Variable Environment`의 경우 `var`로 선언된 변수 혹은 `함수 선언문`등을 저장한다.
- 변수 객체

##### 2-2. outer Environment Reference

---

- 상위 `Lexical Environment`를 참조하는 포인터
- 중립된 자바스크립트 코드에서 `Scope`를 탐색하기 위해 사용

##### 2-2. ThisBinding

---

`this`의 값이 결정되며, 전역 컨텍스트에서 `this`는 `global Object`를 가르킨다.

`함수 실행 컨텍스트`에서 `this`는 호출 방식에 따라 달라진다.

함수가 `Object reference`로 호출되었다면 `this`는 해당 객체를 가르키나, 그렇지 않다면 위에서 말한 `Global Object(window)` 혹은 `strict mode`에서는 `undefined`를 가르키고 있다.

##### 3. ScopeChain

---

![image](https://user-images.githubusercontent.com/56063287/157688114-f109333f-1566-4831-b54a-8e99f1f07017.png)

- 이미지 참조 : [https://muscardinus.tistory.com/190](https://muscardinus.tistory.com/190)

자신의 `Lexical Scope`밖으로 연결할 수 있는 연결고리를 `Scope Chain`이라고 이해하면 될 것 같다.

`Scope Chain`은 부모의 `Environment`의 변수들에 접근할 수 있는 역할을 해준다.

```js
function sayMyName() {
  var a = "a";
  return function findName() {
    var b = "b";
    console.log(a);
    return function printName() {
      var c = "c";
      console.log(a, b);
    };
  };
}

sayMyName()()();
```

위 코드에서 보면 각 함수들은 부모의 `Container`에 있는 변수들에만 접근할 수 있다.

즉, 자식이 부모의 변수에 접근할 수는 있지만, 부모가 자식의 변수에 접근할 수 없다.

##### 3. Function Scope & Block Scope

---

우리가 알고 있는 대부분의 언어는 `Block Scope`로 되어있고 이는 새로운 괄호가 생기면 또하나의 `Lexical Environment`가 생긴다는 것이다.

하지만, `Javascript`는 본질적으로 `Function Scope`로 되어있어 괄호가 아닌 `Global Scope`에서 `Function`이 있는 곳에만 새로운 `Local Environment`를 만든다.

이는 우리가 해당 `Scope`안에서 사용할 수 있는 변수의 범위와 상관이 깊다.

간단한예로 `JS`의 `var`와 `let, const`를 비교해 볼 수 있다.

```js
// Function Scope
function loop() {
  for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}

// Block Scope
function loop2() {
  for (let i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}

loop();
loop2();
```

위 코드에서 `loop`함수의 경우 결과는 아래와 같다.

![image](https://user-images.githubusercontent.com/56063287/157691031-2db8570f-ff57-43b0-a3d3-5a75a49119fd.png)

`var`변수로 선언이 되었고 최종적으로 `i`가 증가되고 `i < 5` 조건에 걸러질때는 이미 `i`값은 증가되어 5가 되었을 것이다.

그러나 `Block Scope`일 경우 해당 반복문을 빠져나오면 `i`에 대한 접근이 불가능해야 할 것이지만 5로 접근이 가능한것을 볼 수 있다.

반면, `loop2`의 경우는 실행하게 되면 아래와 같이 `Error`가 발생하는것을 볼 수 있다.

![image](https://user-images.githubusercontent.com/56063287/157691848-39fa78e6-eca1-4db5-8b14-78e25141dddd.png)

`let`을 사용하면 괄호 안에서 `function Scope`가 아닌 `Block Scope`가 생성되기 때문에 `for`문 밖에서는 `i`값에 접근이 불가능하기 떄문이다.

#### 참고 사이트

---

1. [https://blog.leehov.in/28](https://blog.leehov.in/28)
2. [https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#\_3-environmentrecord%E1%84%8B%E1%85%AA-hoisting-%E1%84%92%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC](https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#_3-environmentrecord%E1%84%8B%E1%85%AA-hoisting-%E1%84%92%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC)
3. [https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context](https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context)
4. [https://muscardinus.tistory.com/190](https://muscardinus.tistory.com/190)
5. [https://velog.io/@hoo00nn/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BDExecution-Context](https://velog.io/@hoo00nn/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BDExecution-Context)
