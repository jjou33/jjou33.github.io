---
title: "실행 컨텍스트(Execution Context)(작성중)"
excerpt: " :computer: 프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다."

categories:
  - executionContext
tags:
  - F/E
  - 실행컨텍스트
  - Execution Context
toc: true
toc_sticky: true
toc_label: "POST LIST"
---

<hr>
:raising_hand:  ```프론트엔드 개발관련 공부내용을 기록하는 포스트 입니다.```
<hr>

#### 1. 개요

---

좋은 기회로 `실행컨텍스트(Execution Context)` 에 대한 궁금증을 갖게 되었다.

중요한 부분은 이 `실행 컨텍스트`가 `Javascript` 에서 굉장히 중요한 역할을 하고 있다는 것이고 아직까지 깊게 공부를 해본적이 없어 이번 기회에 정확히 짚어가고 싶어서 기록을 시작해본다.

여러 기술블로그들을 보며 나름대로 정리해 보았다.

#### 2. 실행 컨텍스트란 무엇일까?

---

실행 컨텍스트는 아래와 같은 개념을 가지고 있다.

```
실행 컨텍스트의 정의

실행 컨텍스트란 자바스크립트 코드가 실행되고 연산되는 범위를 나타내는 추상적인 개념이다.
코드가 실행된다면 실행 컨텍스트 내부에서 실행되고 있는 것이다.

```

즉, `실행 컨텍스트`란 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로서, 동일한 스코프에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 컨텍스트를 구성하고, 이를 `Call Stack`에 쌓아서 실행 순서를 보장한다로 `코어 자바스크립트`책에서는 정의하고 있다.

실행 컨텍스트와 실행 스택(Execution Stack) 개념은 자바스크립트에서 `호이스팅, 클로져, 스코프`와 같은 개념을 이해하는데 깊게 연관이 되는 중요한 내용이므로 정리를 해본다.

#### 3. 실행 컨텍스트(Execution Context) 구성

---

여러가지 `Javascript`에서 발생하는 현상들과 `실행 컨텍스트`는 많은 관련이 있기 때문에 관련되서도 조금 더 공부가 필요할 것 같다.

`실행 컨텍스트`는 아래와 같은 경우에 `Call Stack`에 쌓이고 실행되게 된다.

- 전역 컨텍스트(Global Execution Context)
  - `전역공간`은 자동으로 컨텍스트로 구성된다. 여기서 변수 객체를 생성하는 대신 `this`를 `전역 객체(Global Object)로 활용한다.
- 함수 컨텍스트(Functional Execution Context)
  - `함수`를 실행할 경우 `실행 컨텍스트`가 생성되고, 함수가 동작을 다하면 `Call Stack`에서 삭제된다.
- `eval()`함수를 실행할 경우(Eval Function Execution Context)

실행컨텍스트 요소는 다음과 같이 구성된다.

##### Execution Stack(호출 스택)과 함수 실행 순서

---

`Execution Stack`과 `Call Stack`은 의미상 동일하다.

스택은 `LIFO(Last in, First Out)` 자료구조로 실행하며 실행 컨텍스트들이 저장되는 구조이다.

자바스크립트 엔진이 `<script> Tag`를 만나게 되면 `전역 컨텍스트(Global Context)`를 만들고 실행되고 있는 호출 스택에 이를 `push`한다.

그리고 해당 `script` 코드를 읽어 내려가며 스택에 쌓게 된다.

그리고 자바스크립트 엔진은 `Call Stack` 가장 위에 있는 함수를 실행하고 끝나면 `pop`하여 제거한다.

아래에서 예시를 통해 자세히 알아보자.

#### 실행 컨텍스트의 Call Stack 순서와 기능

---

```js
var a = 1; // 전역 컨텍스트
function outer() {
  // outer 컨텍스트
  function inner() {
    // inner 컨텍스트
    console.log(a); // undefined
    var a = 3;
    console.log(a); // 3
  }
  inner();
  console.log(a); // 1
}
outer();
console.log(a); // 1
```

위와 같은 소스가 실행되게 되면 어떤 순서로 `Call Stack`이 쌓이는지 알아본다.

- Javascript 실행: **[전역컨텍스트]**
- outer 실행 : **[전역컨텍스트, outer]**
- inner 실행 : **[전역컨텍스트, outer, inner]**
- inner 종료 : **[전역컨텍스트, outer]**
- outer 종료 : **[전역컨텍스트]**

![image](https://user-images.githubusercontent.com/56063287/157466130-18ea5664-1c0d-40e4-a86d-950dea34f04a.png)

- 이미지 참조 : [https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context](https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context)

`javascript`파일이 최초 실행 시점에 `전역 컨텍스트`가 활성화되고 `Call Stack`에 쌓이게 된다.

이후 `outer` 함수가 실행되면 `자바스크립트 엔진`은 `outer`에 대한 `환경 정보`를 수집해서 `outer` 실행 컨텍스트를 생성 후 `Call Stack`에 쌓는다.

이후 `outer` 함수 내부의 `inner` 함수의 실행과 동시에 `inner`실행 컨텍스트가 생성되어 스택에 쌓이게 되면 `outer` 컨텍스트는 중단하고 `inner` 함수 내부 코드를 실행한다.

`inner` 함수의 실행이 종료되면 `Call Stack`에서 해당 컨텍스트가 제거되고 `outer` 함수가 이어서 진행된다.

#### 4. 실행 컨텍스트의 구성과 설명

---

자바스크립트엔진이 실행 컨텍스트를 만드는 과정에는 두가지 단계로 진행된다.

1. Creation Phase
2. Execution Phase

##### 4-1. Creation Phase

---

`Creation Phase` 단계에서는 중요한 환경정보를 구성한다.

1. Lexical Environment
2. Variable Environment

`Variable Environment`는 `Lexical Environment`와 비슷하거나 혹은 동일하다고 보면되나 몇가지의 차이점이 있기 때문에 분리하여 설명한다. 하지만, 대부분이 비슷하다고 생각하면 될 것 같다.

###### Lexical Environment

---

`Lexical Environment`는 `Javascript Engine`이 현재 읽고 있는 코드의 `Scope` 혹은 `Environment`를 말한다. 또한 `identifier-variable mapping`이 이루어지는 곳이다.

참조 대상 식별자인 `identifier`는 함수와 변수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름이다.

따라서, `Lexical Environment`에서는 변수와 그 값이 매핑되는 곳이라고 이해하자.

예를 들어 아래와 같은 코드가 있다고 하자

```js
var a = 20;
var b = 40;

function foo() {
  console.log("bar");
}
```

위 코드에 대한 `Lexical Environment`는 아래와 같다.

```js
lexicalEnvironment = {
  a : 20,
  b : 40,
  foo : <ref. to foo function>
}
```

\*\*TODO Lexical 환경과 Variable 환경의 차이가 `var 와 let,const` 일때 어떻게 되는지 보강

```js
var name = "hyunwoo";
function writeName(text) {
  console.log(text + name);
}

function execute() {
  var name = "Super Hyunwoo";
  writeName("HI ");
}
execute();
```

위 실행결과에 따른 컨텍스트 생성은 아래와 같이 될 수 있습니다.

```js
- 전역 컨텍스트(Global Context)
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name', 'writeName', 'execute']
  }
  scopeChain: ['전역 변수 객체']
  this: window
}

- execute 함수 컨텍스트(Functional Execution Context)
{
  '변수 객체': {
    arguments: null,
    variable: [ 'name' ]
  },
  scopeChain: [ 'execute 변수 객체', '전역 변수 객체'],
  this: window
}

- writeName 함수 컨텍스트(Functional Execution Context)
{
  '변수 객체': {
    arguments: [{ text: 'HI ' }],
    variable: null
  },
  scopeChain: [ 'writeName 변수 객체', '전역 변수 객체'],
  this: window
}
```

여기서 결과적으로 찍히는 로그는 아래와 같이 `HI hyunwoo` 가 된다.

이유는 `writeName` 함수 컨텍스트 `ScopeChain`에서 `name`을 찾을 수 없기 때문에 `HI Super Hyunwoo` 가 아닌 전역으로 설정된 `HI hyunwoo`가 나오게 된다.

![image](https://user-images.githubusercontent.com/56063287/157463930-bbac5406-8e2d-46f0-b55d-988e491948e3.png)

이와 같은 방식을 알기위해 `실행 컨텍스트`를 구성할때 우리가 알아야 되는 부분들이 있다.

1. `VariableEnvironment`
2. `Lexical Environment`

##### 1. Lexical Environment

---

새로운 `Lexical Environment`는 괄로({})가 있을때마다 생성된다.

또한 `실행 컨텍스트`가 `JavaScript Engine`에게 현재의 `Lexical Environment`를 알려주는 역할을 하고 이에 맞게 사용할 수 있는 변수를 설정한다.

##### 2. Variable Environment

---

`Variable Environment`의 구성요소 및 `Variable Environment`와 `Lexical Environment`의 차이를 알아본다.

먼저 `Variable Environment`는 `environment record`, `outer environment reference`, `ThisBinding`으로 구성된다.

##### 2-1. Environment Record

---

- 현재 문맥의 식별자 정보(변수나 함수)
  - `Variable Environment`의 경우 `var`로 선언된 변수 혹은 `함수 선언문`등을 저장한다.
- 변수 객체

##### 2-2. outer Environment Reference

---

- 상위 `Lexical Environment`를 참조하는 포인터
- 중립된 자바스크립트 코드에서 `Scope`를 탐색하기 위해 사용

##### 2-2. ThisBinding

---

`this`의 값이 결정되며, 전역 컨텍스트에서 `this`는 `global Object`를 가르킨다.

`함수 실행 컨텍스트`에서 `this`는 호출 방식에 따라 달라진다.

함수가 `Object reference`로 호출되었다면 `this`는 해당 객체를 가르키나, 그렇지 않다면 위에서 말한 `Global Object(window)` 혹은 `strict mode`에서는 `undefined`를 가르키고 있다.

##### 3. ScopeChain

---

![image](https://user-images.githubusercontent.com/56063287/157688114-f109333f-1566-4831-b54a-8e99f1f07017.png)

- 이미지 참조 : [https://muscardinus.tistory.com/190](https://muscardinus.tistory.com/190)

자신의 `Lexical Scope`밖으로 연결할 수 있는 연결고리를 `Scope Chain`이라고 이해하면 될 것 같다.

`Scope Chain`은 부모의 `Environment`의 변수들에 접근할 수 있는 역할을 해준다.

```js
function sayMyName() {
  var a = "a";
  return function findName() {
    var b = "b";
    console.log(a);
    return function printName() {
      var c = "c";
      console.log(a, b);
    };
  };
}

sayMyName()()();
```

위 코드에서 보면 각 함수들은 부모의 `Container`에 있는 변수들에만 접근할 수 있다.

즉, 자식이 부모의 변수에 접근할 수는 있지만, 부모가 자식의 변수에 접근할 수 없다.

##### 3. Function Scope & Block Scope

---

우리가 알고 있는 대부분의 언어는 `Block Scope`로 되어있고 이는 새로운 괄호가 생기면 또하나의 `Lexical Environment`가 생긴다는 것이다.

하지만, `Javascript`는 본질적으로 `Function Scope`로 되어있어 괄호가 아닌 `Global Scope`에서 `Function`이 있는 곳에만 새로운 `Local Environment`를 만든다.

이는 우리가 해당 `Scope`안에서 사용할 수 있는 변수의 범위와 상관이 깊다.

간단한예로 `JS`의 `var`와 `let, const`를 비교해 볼 수 있다.

```js
// Function Scope
function loop() {
  for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}

// Block Scope
function loop2() {
  for (let i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}

loop();
loop2();
```

위 코드에서 `loop`함수의 경우 결과는 아래와 같다.

![image](https://user-images.githubusercontent.com/56063287/157691031-2db8570f-ff57-43b0-a3d3-5a75a49119fd.png)

`var`변수로 선언이 되었고 최종적으로 `i`가 증가되고 `i < 5` 조건에 걸러질때는 이미 `i`값은 증가되어 5가 되었을 것이다.

그러나 `Block Scope`일 경우 해당 반복문을 빠져나오면 `i`에 대한 접근이 불가능해야 할 것이지만 5로 접근이 가능한것을 볼 수 있다.

반면, `loop2`의 경우는 실행하게 되면 아래와 같이 `Error`가 발생하는것을 볼 수 있다.

![image](https://user-images.githubusercontent.com/56063287/157691848-39fa78e6-eca1-4db5-8b14-78e25141dddd.png)

`let`을 사용하면 괄호 안에서 `function Scope`가 아닌 `Block Scope`가 생성되기 때문에 `for`문 밖에서는 `i`값에 접근이 불가능하기 떄문이다.

#### 참고 사이트

---

1. [https://blog.leehov.in/28](https://blog.leehov.in/28)
2. [https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#\_3-environmentrecord%E1%84%8B%E1%85%AA-hoisting-%E1%84%92%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC](https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#_3-environmentrecord%E1%84%8B%E1%85%AA-hoisting-%E1%84%92%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC)
3. [https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context](https://velog.io/@vlfflq2004/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Execution-Context)
4. [https://muscardinus.tistory.com/190](https://muscardinus.tistory.com/190)
5. [https://velog.io/@hoo00nn/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BDExecution-Context](https://velog.io/@hoo00nn/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BDExecution-Context)
